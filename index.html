<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<style>
		  html {
		    font-size: 16px; /* 1rem = 16px */
		  }
		  body {
		    -webkit-text-size-adjust: 100%; /* verhindert iOS-Autozoom */
		    font-family: Arial, sans-serif; /* oder dein gew√ºnschter Font */
		  }
		</style>

	  
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://code.highcharts.com/stock/highstock.js"></script>
    <script src="https://code.highcharts.com/stock/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script type="text/javascript">
    
	var dynamicChart;
	var channelsLoaded = 0;
	var channelKeys =[];
	channelKeys.push({
            channelNumber: 1304805,
            name: 'Wetterstation',
            key: '1H5R2K6OL295TNP8',
            fieldList: [
                {field:1, axis:'T', unit:'¬∞C'},
                {field:2, axis:'H', unit:'%'},
                {field:3, axis:'T', unit:'g/m¬≥'},
                {field:4, axis:'T', unit:'¬∞C'},
                {field:5, axis:'T', unit:'¬∞C'},
                {field:6, axis:'T', unit:'¬∞C'},
                {field:7, axis:'T', unit:'mm'},   // spezielle Einheit f√ºr Feld 7
                {field:8, axis:'P', unit:''}      // keine Einheit f√ºr Feld 8
            ]
        });

	                
	// user's timezone offset
	var myOffset = new Date().getTimezoneOffset();
	
	// converts date format from JSON
	function getChartDate(d) {
	    return Date.UTC(d.substring(0,4), d.substring(5,7)-1, d.substring(8,10), d.substring(11,13), d.substring(14,16), d.substring(17,19)) - (myOffset * 60000);
	}
	
	      // Hide all series, via 'Hide All' button.  Then user can click on serries name in legent to show series of interest.      
	function HideAll(){
	  for (var index=0; index<dynamicChart.series.length; index++)  // iterate through each series
	  { 
	    if (dynamicChart.series[index].name == 'Navigator')
	      continue;
	    dynamicChart.series[index].hide();
	    //window.console && console.log('Series Number:',index,' Name:',dynamicChart.series[index].name);
	  }
	  //});
	            
	}
	      
	      //  This is where the chart is generated.
	$(document).ready(function() 
	{
	 //Add Channel Load Menu
	 var menu=document.getElementById("Channel Select");
	 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
	 {
	   window.console && console.log('Name',channelKeys[channelIndex].name);
	   var menuOption =new Option(channelKeys[channelIndex].name,channelIndex);
	   menu.options.add(menuOption,channelIndex);
	 }
	 var last_date; // variable for the last date added to the chart
	 window.console && console.log('Testing console');
	 //make series numbers for each field
	 var seriesCounter=0
	 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
	  {
	    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // iterate through each channel
	      {
	        channelKeys[channelIndex].fieldList[fieldIndex].series = seriesCounter; 
	        seriesCounter++;
	      }
	  }
 //make calls to load data from each channel into channelKeys array now
 // draw the chart when all the data arrives, later asyncronously add history
 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    channelKeys[channelIndex].loaded = false;  
    loadThingSpeakChannel(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList);
    
  }
 //window.console && console.log('Channel Keys',channelKeys);
 
 // load the most recent 2500 points (fast initial load) from a ThingSpeak channel into a data[] array and return the data[] array
 function loadThingSpeakChannel(sentChannelIndex,channelNumber,key,sentFieldList) {
   var fieldList= sentFieldList;
   var channelIndex = sentChannelIndex;
   // get the Channel data with a webservice call
   $.getJSON('https://api.thingspeak.com/channels/'+channelNumber+'/feed.json?&amp;offset=0&amp;results=2500;api_key='+key, function(data)
   //$.getJSON('https://www.thingspeak.com/channels/'+channelNumber+'/feed.json?callback=?&amp;offset=0&amp;results=2500;key='+key, function(data)
   {
	   // if no access
	   if (data == '-1') {
       $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
       window.console && console.log('Thingspeak Data Loading Error');
     }
     for (var fieldIndex=0; fieldIndex<fieldList.length; fieldIndex++)  // iterate through each field
     {
       fieldList[fieldIndex].data =[];
       for (var h=0; h<data.feeds.length; h++)  // iterate through each feed (data point)
       {
         var p = []//new Highcharts.Point();
         var fieldStr = "data.feeds["+h+"].field"+fieldList[fieldIndex].field;
		  	 var v = eval(fieldStr);
 		  	p[0] = getChartDate(data.feeds[h].created_at);
	 	  	p[1] = parseFloat(v);
	 	  	// if a numerical value exists add it
	   		if (!isNaN(parseInt(v))) { fieldList[fieldIndex].data.push(p); }
       }
       fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
	   }
     window.console && console.log('getJSON field name:',fieldList[0].name);
     channelKeys[channelIndex].fieldList=fieldList;
     channelKeys[channelIndex].loaded=true;
     channelsLoaded++;
     window.console && console.log('channels Loaded:',channelsLoaded);
     window.console && console.log('channel index:',channelIndex);
     if (channelsLoaded==channelKeys.length){createChart();}
	 })
   .fail(function() { alert('getJSON request failed! '); });
 }


 // create the chart when all data is loaded
 function createChart() {
	// specify the chart options
	var chartOptions = {
	  chart: 
    {
		marginTop: 10,    // Abstand oben
	    marginBottom: 60,  // Abstand unten (Legende / Navigator)
	  renderTo: 'chart-container',
      zoomType:'y',
			events: 
      {
        load: function() 
        {
				  if ('true' === 'true' && (''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1)) 
          {
            // If the update checkbox is checked, get latest data every 15 seconds and add it to the chart
						setInterval(function() 
            {
             if (document.getElementById("Update").checked)
             {
              for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
              {  
               (function(channelIndex)
               {
                // get the data with a webservice call
				$.getJSON('https://api.thingspeak.com/channels/'+channelKeys[channelIndex].channelNumber+'/feed/last.json?&amp;offset=0&amp;location=false;api_key='+channelKeys[channelIndex].key, function(data)
				//$.getJSON('https://www.thingspeak.com/channels/'+channelKeys[channelIndex].channelNumber+'/feed/last.json?callback=?&amp;offset=0&amp;location=false;key='+channelKeys[channelIndex].key, function(data)   
                { 
                  for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)
                  {
                    // if data exists
                    var fieldStr = "data.field"+channelKeys[channelIndex].fieldList[fieldIndex].field;
                    var chartSeriesIndex=channelKeys[channelIndex].fieldList[fieldIndex].series;
                    if (data && eval(fieldStr)) 
                    {
                      var p = []//new Highcharts.Point();
                      var v = eval(fieldStr);
                      p[0] = getChartDate(data.created_at);
                      p[1] = parseFloat(v);
                      // get the last date if possible
                      if (dynamicChart.series[chartSeriesIndex].data.length > 0) 
                      { 
                        last_date = dynamicChart.series[chartSeriesIndex].data[dynamicChart.series[chartSeriesIndex].data.length-1].x; 
                      }
                      var shift = false ; //default for shift
                      // if a numerical value exists and it is a new date, add it
                      if (!isNaN(parseInt(v)) && (p[0] != last_date)) 
                      {
                        dynamicChart.series[chartSeriesIndex].addPoint(p, true, shift);
                      }   
                    }
                    //window.console && console.log('channelKeys:',channelKeys);
                    //window.console && console.log('chartSeriesIndex:',chartSeriesIndex);
                    //window.console && console.log('channel index:',channelIndex);
                    //window.console && console.log('field index:',fieldIndex);
                    //window.console && console.log('update series name:',dynamicChart.series[chartSeriesName].name);
                    //window.console && console.log('channel keys name:',channelKeys[channelIndex].fieldList[fieldIndex].name);
                  }
                  
                  
                });
               })(channelIndex);
              }
              // Nach dem Update der Series auch die Anzeige aktualisieren:
              updateCurrentValues();
             }
						}, 10000);
					}
				}
			}
		},
		rangeSelector: {
			buttons: [{
				count: 30,
				type: 'minute',
				text: '30M'
			},{
				count: 1,
				type: 'hour',
				text: '1H'
      },{
				count: 2,
				type: 'hour',
				text: '2H'
      },{
				count: 4,
				type: 'hour',
				text: '4H'
      }, {
				count: 12,
				type: 'hour',
				text: '12H'
      }, {
				count: 1,
				type: 'day',
				text: 'D'
      }, {
				count: 1,
				type: 'week',
				text: 'W'
      }, {
				count: 1,
				type: 'month',
				text: 'M'
      }, {
				count: 1,
				type: 'year',
				text: 'Y'
			}, {
				type: 'all',
				text: 'All'
			}],
			inputEnabled: false,
			selected: 3,
			buttonTheme: {
			  width: 24,       // Breite der Buttons
			  height: 15,      // H√∂he der Buttons
			  style: {
						fontSize: '8px'
					}
			  }
		},
    title: {
			text: ''
		},
		credits: {
  		  enabled: false
		},

		plotOptions: {
		  line: {
        gapSize:5
				//color: '#d62020'
				//  },
				//  bar: {
				//color: '#d52020'
				//  },
				//  column: {
			},
			series: {
			  marker: {
				  radius: 2
				},
				animation: true,
				step: false,
        turboThrehold:1000,
				borderWidth: 0
			}
		},
    tooltip: {
      valueDecimals: 1,
      //valueSuffix: '¬∞F',
      xDateFormat:'%Y-%m-%d<br/>%H:%M:%S',
		style: {
        fontSize: '9px',   // üëà Schriftgr√∂√üe √§ndern
        fontFamily: 'Arial, sans-serif',
        color: '#333'
    	}
    },
		xAxis: {
		  type: 'datetime',
      			ordinal:false,
      			min: Date.UTC(2013,02,28),
				dateTimeLabelFormats : {
        			hour: '%k %p',
        			minute: '%k:%M'
        			//hour: '%l %p',
        			//minute: '%l:%M %p'
      		},
     		 labels: {
        style: {
				fontSize: '8px', // Schriftgr√∂√üe √§ndern
				color: '#333'     // optional, Schriftfarbe
		       }
		    },
		    title: {
		        text: null // Titel entfernen
		    }
		},
		yAxis: [{
            title: {
                //text: 'Temperatur (¬∞C)'
            },
            id: 'T',
			labels: {
					style: {
                    fontSize: '8px' // optional Schriftgr√∂√üe anpassen
                  }
            }
    }, {
            title: {
                //text: 'Luftfeuchtigkeit (g/m¬≤)'
            },
            opposite: false,
            id: 'H',
            labels: {
                  align: 'left', // linksb√ºndig innerhalb des Achsenbereichs
                  x: 0, // verschiebt die Achsenwerte nach links
                  y: -2,
                  style: {
                      fontSize: '8px' // optional Schriftgr√∂√üe anpassen
                  }
            }
    }, {
            title: {
                //text: 'Luftdruck'
            },
            opposite: false,
            id: 'P',
            labels: {
                  align: 'left', // linksb√ºndig innerhalb des Achsenbereichs
                  x: 0, // verschiebt die Achsenwerte nach links
                  y: 11,
                  style: {
                      fontSize: '8px' // optional Schriftgr√∂√üe anpassen
                  }
            }
    }],
		exporting: {
		enabled: true,
		sourceWidth: 1500, 
                sourceHeight: 1000,
                scale: 1 ,
      csv: {
        dateFormat: '%d/%m/%Y %H:%M:%S'
        }
		},
		legend: {
                    enabled: true,
                    itemStyle: {
                        fontSize: '8px',
                        fontWeight: 'normal',
                        cursor: 'pointer'
                    },
                    itemHoverStyle: {
                        color: '#000000'
                    },
                    symbolHeight: 8, // H√∂he des Legenden-K√§stchens
                    symbolWidth: 8,   // Breite des Legenden-K√§stchens
					itemMarginTop: 0,     // Abstand oberhalb jedes Eintrags
    				itemMarginBottom: 0,  // Abstand unterhalb jedes Eintrags
					y: 20                   // verschiebt die Legende n√§her an den Chart
                },
    navigator: {
	    enabled: false,
	    outlineWidth: 0,            // Rahmen entfernen
	    maskFill: 'rgba(0,0,0,0)',  // Schattierung transparent
	    handles: {
	        backgroundColor: 'transparent',
	        borderColor: 'transparent'
	    }
	},
	scrollbar: {
	    enabled: false               // Scrollbalken komplett deaktivieren
	},
	
	series: []                       // üëà Jetzt auf der richtigen Ebene

    //series: [{data:[[getChartDate("2013-06-16T00:32:40Z"),75]]}]      
	};

	// add all Channel data to the chart
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // add each field
    {
      window.console && console.log('Channel '+channelIndex+' field '+fieldIndex);
      chartOptions.series.push({data:channelKeys[channelIndex].fieldList[fieldIndex].data,
                                index:channelKeys[channelIndex].fieldList[fieldIndex].series,
                                yAxis:channelKeys[channelIndex].fieldList[fieldIndex].axis,
                                //visible:false,
                              name: channelKeys[channelIndex].fieldList[fieldIndex].name});
    }
    updateCurrentValues();
  }
	// set chart labels here so that decoding occurs properly
	//chartOptions.title.text = data.channel.name;
	// chartOptions.xAxis.title.text = 'Uhrzeit';

	// draw the chart
  dynamicChart = new Highcharts.StockChart(chartOptions);
  
  // Felder bei Start ausbleden
  dynamicChart.series[4].hide();  
  dynamicChart.series[5].hide();  

  // Buttons erstellen
  createSeriesButtons();

	// Emoji-Updater starten, **nachdem die Daten da sind**
	updateWeatherEmoji();       // Emoji sofort korrekt setzen
	startWeatherEmojiUpdater(); // dann jede Minute aktualisieren
  
  // update series number to account for the navigator series (The historical series at the bottom) which is the first series.
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // and each field
    {
      for (var seriesIndex=0; seriesIndex<dynamicChart.series.length; seriesIndex++)  // compare each series name
      {
        if (dynamicChart.series[seriesIndex].name == channelKeys[channelIndex].fieldList[fieldIndex].name)
        {
          channelKeys[channelIndex].fieldList[fieldIndex].series = seriesIndex;
        }
      }
    }
  }          
  // add all history
  //dynamicChart.showLoading("Loading History..." );
  window.console && console.log('Channels: ',channelKeys.length);
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    window.console && console.log('channelIndex: ',channelIndex);
    (function(channelIndex)
      {
        //load only 1 set of 8000 points
        loadChannelHistory(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList,0,1); 
      }
    )(channelIndex);
  }
  // Emoji-Updater starten
    startWeatherEmojiUpdater();
 }
 
});

function updateClock() {
    const now = new Date();

    // Deutsche Wochentage & Monate
    const days = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
    const months = ["Jan", "Feb", "M√§r", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"];

    const dayName = days[now.getDay()];
    const day = now.getDate();
    const month = months[now.getMonth()];

    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');

    const formattedTime = `${hours}:${minutes}:${seconds}`;
    const formattedDate = `${dayName}, ${day}. ${month}`;

    document.getElementById("clock").innerHTML = `
        <div style="text-align:right; line-height:0.8;">
            <span style="font-size:1.2rem; font-weight:bold; color:#333;">${formattedTime}</span><br>
            <span style="font-size:0.7rem; color:#555;">${formattedDate}</span>
        </div>
    `;
}

// Uhr jede Sekunde aktualisieren
setInterval(updateClock, 1000);
updateClock(); // sofort starten

		
function updateCurrentValues() {
  let container = document.getElementById("current-values");
  container.innerHTML = ''; // Leeren vor Neubef√ºllung

  for (let channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) {
    const channel = channelKeys[channelIndex];

    for (let i = 0; i < channel.fieldList.length; i++) {
      const field = channel.fieldList[i];
      let latestValue = 'n/a';

      if (field.data && field.data.length > 0) {
        latestValue = field.data[field.data.length - 1][1];
      }

	  //buttonscurrentvalue
      let box = document.createElement('div');
      box.style.border = "1px solid #ccc";
      box.style.padding = "2px";
      box.style.borderRadius = "5px";
      box.style.minWidth = "auto";
      box.style.textAlign = "center";
      box.style.backgroundColor = "#f9f9f9";

      // Einheit anh√§ngen, falls definiert
      const unit = field.unit ? ` ${field.unit}` : '';
      const roundedValue = Number(latestValue).toFixed(1);
      const unitHTML = field.unit ? `<span style="font-size: 0.6em;">${field.unit}</span>` : '';
      box.innerHTML = `<span style="font-size: 1.5rem; font-weight: bold;">${roundedValue}${unitHTML}</span><br>
                      <strong style="font-size: 0.6rem;">${field.name}</strong>`;

		//  Klick-Event auf die Box
      	box.addEventListener("click", openCurrentValuesOverlay);
		
      container.appendChild(box);
    }
  }
}

// Overlay √∂ffnen
function openCurrentValuesOverlay() {
    const overlay = document.getElementById("current-values-overlay");
    const overlayContent = document.getElementById("overlay-content");
    overlayContent.innerHTML = ''; // vorher leeren

    // alle Werte einf√ºgen
    for (let channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) {
        const channel = channelKeys[channelIndex];
        for (let i = 0; i < channel.fieldList.length; i++) {
            const field = channel.fieldList[i];
            let latestValue = 'n/a';
            if (field.data && field.data.length > 0) {
                latestValue = field.data[field.data.length - 1][1];
            }
            const unitHTML = field.unit ? ` ${field.unit}` : '';
            const roundedValue = Number(latestValue).toFixed(1);

            overlayContent.innerHTML += `
			    <div style="
			        font-size: 2rem;          
			        font-weight: bold;
			        margin: 6px 0;             
			        background-color: rgba(255,255,255,0.9);
			        color: black;              
			        padding: 6px 10px;         
			        border-radius: 8px;
			        line-height: 1.1;          /* engerer Abstand zwischen Zeilen */
			        text-align: center;
			    ">
			        <div style="margin:0; padding:0;">${roundedValue}${unitHTML}</div>
			        <div style="font-size:0.9rem; font-weight:normal; color:gray; margin-top:2px; line-height:1;">${field.name}</div>
			    </div>
			`;

        }
    }

    // Overlay anzeigen
    overlay.style.display = 'block';
}

// Overlay √ºberall anklickbar zum Schlie√üen
const overlay = document.getElementById("current-values-overlay");

overlay.addEventListener("click", function() {
    overlay.style.display = 'none';
});





function updateWeatherEmoji() {
    const channel = channelKeys[0]; // erster Kanal

    // Feste Felder abrufen
    const tempField = channel.fieldList.find(f => f.field === 1);
    const humField = channel.fieldList.find(f => f.field === 2);
    const pressureField = channel.fieldList.find(f => f.field === 8);

    // Pr√ºfen, ob die Felder existieren und Daten enthalten
    if (!tempField || !humField || !pressureField) return;
    if (!tempField.data || !tempField.data.length) return;
    if (!humField.data || !humField.data.length) return;
    if (!pressureField.data || !pressureField.data.length) return;

    const latestTemp = tempField.data[tempField.data.length - 1][1];
    const latestHum = humField.data[humField.data.length - 1][1];
    const latestPressure = pressureField.data[pressureField.data.length - 1][1];

    let emoji = "üå°Ô∏è"; // Standard

    // Logik f√ºr Emoji basierend auf mehreren Parametern
    if (latestTemp <= 0) {
        emoji = "‚ùÑÔ∏è"; // Kalt/Schnee
    } else if (latestHum > 80 && latestTemp < 20) {
        emoji = "üåßÔ∏è"; // Regen
    } else if (latestHum < 50 && latestTemp > 25) {
        emoji = "‚òÄÔ∏è"; // Sonnig/Hei√ü
    } else if (latestHum > 60 && latestPressure < 1000) {
        emoji = "‚õàÔ∏è"; // Gewitterwahrscheinlichkeit
    } else if (latestHum >= 50 && latestTemp <= 15) {
        emoji = "üå•Ô∏è"; // Wolkig/K√ºhl
    } else {
        emoji = "üå§Ô∏è"; // Mild/Sonnig
    }

    document.getElementById("header-title").innerHTML = `${emoji}Wetterstation`;
}

// === Wichtiger Schritt: erst nach dem Laden der Daten aufrufen ===
function startWeatherEmojiUpdater() {
    // Sofort aufrufen, wenn Daten da sind
    updateWeatherEmoji();
    // Dann jede Minute aktualisieren
    setInterval(updateWeatherEmoji, 60000);
}


function createSeriesButtons() {
    const container = document.getElementById("buttons-container");

    // Container als flexbox f√ºr gleichm√§√üige Anordnung
    container.innerHTML = ''; // vorherige Buttons l√∂schen
    container.style.display = 'flex';
    container.style.flexWrap = 'wrap';
    container.style.alignItems = 'center'; // vertikal zentrieren
    container.style.gap = '2px';           // Abstand zwischen Buttons

    for (let channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) {
        const channel = channelKeys[channelIndex];

        for (let i = 0; i < channel.fieldList.length; i++) {
            const field = channel.fieldList[i];

            // Nur bestimmte Buttons erstellen
            if (field.name.includes("Tages min. Temperatur") || field.name.includes("Tages max. Temperatur")) {
                continue; // Button nicht erzeugen
            }
			// Chartbuttons
            const button = document.createElement('button');
            button.style.width = '56px';
            button.style.minHeight = '40px';      // garantiert Mindesth√∂he
            button.style.fontSize = '8px';
            button.style.fontWeight = 'bold';
            button.style.margin = '5px';
            button.style.whiteSpace = 'normal';   // Text darf umbrechen
            button.style.textAlign = 'center';
            button.style.padding = '0';         // innenabstand
            button.style.boxSizing = 'border-box';
            button.style.display = 'flex';
            button.style.alignItems = 'center';      // Text vertikal zentrieren
            button.style.justifyContent = 'center';  // Text horizontal zentrieren
            button.textContent = field.name;
            button.style.border = 'none';          // kein Rand
            button.style.outline = 'none';         // kein Fokus-Rahmen

            // Statusfarbe initial setzen
            const series = dynamicChart.series[field.series];
            button.style.backgroundColor = series.visible ? '#e6eaff' : '#f7f7f7'; // blau = sichtbar, grau = ausgeblendet
            button.style.color = series.visible ? 'black' : 'gray';

            // Klick-Handler
            button.onclick = function() {
                series.visible ? series.hide() : series.show();
                // Buttonfarbe aktualisieren
                button.style.backgroundColor = series.visible ? '#e6eaff' : '#f7f7f7'; // blau = sichtbar, grau = ausgeblendet
                button.style.color = series.visible ? 'black' : 'gray';
            };

            container.appendChild(button);
        }
    }
}


      
function loadOneChannel(){ 
  // load a channel selected in the popUp menu.
  var selectedChannel=document.getElementById("Channel Select");
  var maxLoads=document.getElementById("Loads").value ;
  var channelIndex = selectedChannel.selectedIndex;
  loadChannelHistory(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList,0,maxLoads); 
} 

// load next 8000 points from a ThingSpeak channel and addPoints to a series
function loadChannelHistory(sentChannelIndex,channelNumber,key,sentFieldList,sentNumLoads,maxLoads) {
   var numLoads=sentNumLoads
   var fieldList= sentFieldList;
   var channelIndex = sentChannelIndex;
   var first_Date = new Date();
   if (typeof fieldList[0].data[0] != "undefined") first_Date.setTime(fieldList[0].data[0][0]+7*60*60*1000);//adjust for 7 hour difference from GMT (Zulu time)
   else if (typeof fieldList[1].data[0] != "undefined") first_Date.setTime(fieldList[1].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[2].data[0] != "undefined") first_Date.setTime(fieldList[2].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[3].data[0] != "undefined") first_Date.setTime(fieldList[3].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[4].data[0] != "undefined") first_Date.setTime(fieldList[4].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[5].data[0] != "undefined") first_Date.setTime(fieldList[5].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[6].data[0] != "undefined") first_Date.setTime(fieldList[6].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[7].data[0] != "undefined") first_Date.setTime(fieldList[7].data[0][0]+7*60*60*1000);
   var end = first_Date.toJSON();
   window.console && console.log('earliest date:',end);
   window.console && console.log('sentChannelIndex:',sentChannelIndex);
   window.console && console.log('numLoads:',numLoads);
   // get the Channel data with a webservice call
   $.getJSON('https://api.thingspeak.com/channels/'+channelNumber+'/feed.json?&amp;offset=0&amp;start=2020-01-01T00:00:00;end='+end+';api_key='+key, function(data) 
   //$.getJSON('https://www.thingspeak.com/channels/'+channelNumber+'/feed.json?callback=?&amp;offset=0&amp;start=2013-01-20T00:00:00;end='+end+';key='+key, function(data) 
   {
	   // if no access
	   if (data == '-1') {
       $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
       window.console && console.log('Thingspeak Data Loading Error');
     }
     for (var fieldIndex=0; fieldIndex<fieldList.length; fieldIndex++)  // iterate through each field
     {
       //fieldList[fieldIndex].data =[];
       for (var h=0; h<data.feeds.length; h++)  // iterate through each feed (data point)
       {
         var p = []//new Highcharts.Point();
         var fieldStr = "data.feeds["+h+"].field"+fieldList[fieldIndex].field;
		  	 var v = eval(fieldStr);
 		  	p[0] = getChartDate(data.feeds[h].created_at);
	 	  	p[1] = parseFloat(v);
	 	  	// if a numerical value exists add it
	   		if (!isNaN(parseInt(v))) { fieldList[fieldIndex].data.push(p); }
       }
       fieldList[fieldIndex].data.sort(function(a,b){return a[0]-b[0]});
       dynamicChart.series[fieldList[fieldIndex].series].setData(fieldList[fieldIndex].data,false);
       //dynamicChart.series[fieldList[fieldIndex].series].addPoint(fieldList[fieldIndex].data,false);
       //fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
       //window.console && console.log('data added to series:',fieldList[fieldIndex].series,fieldList[fieldIndex].data);
	   }
     channelKeys[channelIndex].fieldList=fieldList;
     dynamicChart.redraw()
     window.console && console.log('channel index:',channelIndex);
     numLoads++;
     if (numLoads<maxLoads) {loadChannelHistory(channelIndex,channelNumber,key,fieldList,numLoads,maxLoads);}
	 });
}

</script>
<!-- HTML ################################################################################################################### -->
<title>Wetterstation</title>
</head>
<body style="background-color: white;">
<!-- Abstand -->
<div style="height:2px;"></div>
	
<!-- √úberschrift -->
<h1 style="display: flex; justify-content: space-between; align-items: center; 
           font-family: Arial; font-size: 1.8rem; margin: 2px;">
  <span id="header-title">üå§Ô∏èWetterstation</span>
  <span id="clock" style="font-size: 1.0rem; font-weight: bold; color: #777777;"></span>
</h1>
	
<!-- Trennlinie -->
<hr style="border: none; border-top: 1px solid #ccc; margin: 5px 0 10px 0;">
	
<!-- Zusatzinfos -->
<p style="
  font-size: 0.5rem; 
  font-family: Arial;
  color: #666; 
  margin-top: 0px; 
  margin: 5px;
  display: flex; 
  justify-content: space-between;
">
  <span>üìç Hochspeyer, Rheinland-Pfalz - 280 m √º. NN</span>
  <span>ESP8266, BME280 & MISOL Regenmesser </span>
</p>

<!-- Felder aktuelle Werte -->
<div id="current-values" style="font-family: Arial; margin: 2px; gap: 5px;">
  <!-- Hier werden die aktuellen Werte dynamisch eingef√ºgt -->
</div>
<!-- Overlay f√ºr gro√üe aktuelle Werte -->
<div id="current-values-overlay" style="
    display:none;
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background-color: rgba(255,255,255,0.1); /* hell/transparenter Hintergrund */
    color:black;
    z-index:9999;
    font-family: Arial, sans-serif;
    overflow:auto;
    padding-top:10px;
    box-sizing:border-box;
    text-align:center;
">
    <div id="overlay-content" style="max-width:400px; margin:auto;"></div>
</div>


<!-- Chart / Diagramm -->
<div id="chart-container" style="height: 300px;"><br>
  Daten werden geladen...<br>
</div>

<!-- Buttons zum ein/ausschalten der Linien -->
<!--<div id="buttons-container" style="margin-top:10px;"></div>
<div style="height:20px;"></div>-->

<!-- Steuerelemente des Charts - Ausgeblendet -->
<div id="below chart"> <button style="width: 110px; margin-top: -18px;" value="Hide All"
	name="Hide All Button"
	onclick="HideAll();">Alle ausbleden</button><button style="width: 200px; margin-top: -18px;" value="Load More Data"
	name="Load More Data"
	onclick="loadOneChannel();">Mehr historische Daten laden</button>
  <select id="Channel Select">
  </select>
  <select id="Loads">
	<option value="1">1 Datens√§tze</option>
	<option value="2">2 Datens√§tze</option>
	<option value="3">3 Datens√§tze</option>
	<option value="4">4 Datens√§tze</option>
	<option value="5">5 Datens√§tze</option>
	<option value="6">6 Datens√§tze</option>
	<option value="7">7 Datens√§tze</option>
	<option value="8">8 Datens√§tze</option>
	<option value="9">9 Datens√§tze</option>
	<option value="10">10 Datens√§tze</option>
	<option value="15">15 Datens√§tze</option>
	<option value="20"selected="selected">20 Datens√§tze</option>
	<option value="25">25 Datens√§tze</option>
	<option value="30">30 Datens√§tze</option>
	<option value="40">40 Datens√§tze</option>
	<option value="50">50 Datens√§tze</option>
  </select>
  <input id="Update" name="Update" type="checkbox" checked><span style="font-family: Arial;">Daten automatisch nachladen</span> 
  <span id="Latency" style="font-family: Arial;">(Latency)</span>
</div>
    
<!-- Button f√ºr mehr historische Daten -->
<div style="text-align:center; margin-top: 0;">
  <button 
    onclick="loadOneChannel();" 
    style="padding: 3px 6px; font-size: 0.55rem; border:none; outline:none; border-radius:3px; background-color:#e6eaff; color:#333; cursor:pointer;">
    Mehr historische Daten laden
  </button>
</div>


<!-- Trennlinie -->
<hr style="border: none; border-top: 1px solid #ccc; margin: 5px 0 10px 0;">
    
<!-- Wettervorhersage Widget -->    
<a class="weatherwidget-io" href="https://forecast7.com/de/49d447d90/hochspeyer/" data-label_1="HOCHSPEYER" data-label_2="WEATHER" data-icons="Climacons Animated" data-mode="Forecast" data-theme="original" data-basecolor="#e6eaff" data-textcolor="#535353" data-highcolor="#a15757" data-lowcolor="#5296f8" >HOCHSPEYER WEATHER</a>
<script>
!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src='https://weatherwidget.io/js/widget.min.js';fjs.parentNode.insertBefore(js,fjs);}}(document,'script','weatherwidget-io-js');
</script>


<!-- Impressum Button -->
<button onclick="document.getElementById('impressum').style.display='block'" 
        style="position:fixed; bottom:-40px; left:50%; transform:translateX(-50%);
               border:none; outline:none; border-radius: 3px;
               font-size:0.9em; color:#666; cursor:pointer;">
  Impressum
</button>

<!-- Overlay -->
<div id="impressum" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
     background-color:rgba(0,0,0,0.7); color:white; padding:50px; box-sizing:border-box; overflow:auto;">
  <div style="background-color:#fff; color:#000; padding:20px; border-radius:8px; max-width:600px; margin:auto; font-family: Arial, sans-serif;">
    <h2>Impressum</h2>

    <p><strong>Angaben gem√§√ü ¬ß 5 TMG:</strong><br>
    Jan Gassen<br>
    √úber den B√§chelwiesen 1<br>
    67691 Hochspeyer<br>
    Deutschland</p>

    <p><strong>Kontakt:</strong><br>
    E-Mail: jg-pp [at] mail [dot] de<br></p>

    <p><strong>Haftungsausschluss:</strong><br>
    Trotz sorgf√§ltiger inhaltlicher Kontrolle √ºbernehmen wir keine Haftung f√ºr die Inhalte externer Links.<br>F√ºr den Inhalt der verlinkten Seiten sind ausschlie√ülich deren Betreiber verantwortlich.</p>
    
    <p><strong>Hinweis:</strong> Diese Website ist ein privates / nicht kommerzielles Projekt.</p>
    <button onclick="document.getElementById('impressum').style.display='none'">Schlie√üen</button>
  </div>
</div>
<!-- debuginfos -->	
<button id="debug-toggle" style="
    position: fixed;
    bottom: -40px;
    left: 8px;
    background: transparent;
    color: gray;
    border: none;
    padding: 4px 8px;
    font-size: 0.8rem;
    font-family: sans-serif;
    cursor: pointer;
    z-index: 9999;
    transition: color 0.2s ease;
">debug</button>
<div id="debug-info" style="
    display: none;
    position: fixed;
    bottom: 50px;
    left: 8px;
    background: rgba(0, 0, 0, 0.85);
    color: #fff;
    padding: 10px 14px;
    border-radius: 10px;
    font-size: 0.8rem;
    font-family: monospace;
    z-index: 9999;
    white-space: pre-line;
    max-width: 90vw;
"></div>
<script>
function getDebugInfo() {
  return [
    `üì± User agent: ${navigator.userAgent}`,
    `üìè Viewport: ${window.innerWidth} x ${window.innerHeight}`,
    `üñ•Ô∏è Screen: ${screen.width} x ${screen.height}`,
    `üî§ DPR: ${window.devicePixelRatio}`,
    `üåê Orientation: ${screen.orientation?.type || "n/a"}`,
    `üß≠ Platform: ${navigator.platform}`
  ].join('\n');
}

const debugInfo = document.getElementById("debug-info");
const debugButton = document.getElementById("debug-toggle");

debugButton.addEventListener("click", () => {
  if (debugInfo.style.display === "none") {
    debugInfo.textContent = getDebugInfo();
    debugInfo.style.display = "block";
  } else {
    debugInfo.style.display = "none";
  }
});

window.addEventListener("resize", () => {
  if (debugInfo.style.display === "block") {
    debugInfo.textContent = getDebugInfo();
  }
});

// Skalierung
const targetWidth = 412;
function applyScale() {
    const scale = window.innerWidth / targetWidth;
    document.body.style.transform = `scale(${scale})`;
    document.body.style.transformOrigin = 'top left';
    document.body.style.width = `${targetWidth}px`;
    document.body.style.margin = '0';
}

// sofort anwenden
applyScale();

// bei Resize erneut anwenden
window.addEventListener('resize', applyScale);

	
</script>

	<!-- Felder aktuelle Werte oben -->
  </body>
      <style>
		body {
		    margin: 0;
		    padding: 0;
		    box-sizing: border-box;
		}

		
		#current-values {
		  display: grid;
		  grid-template-columns: repeat(4, 1fr);
		  justify-content: center;
		  gap: 8px;
		  width: fit-content; /* passt Breite ans Grid an */
		  margin: 0 auto;     /* zentriert das Grid */
		  padding: 0 4px;
		  box-sizing: border-box;
		}
		
		
		#current-values div {
		    border: 1px solid #ccc;
		    padding: 10px;
		    border-radius: 8px;
		    text-align: center;
		    background-color: #f0f0f0;
		    font-family: Arial, sans-serif;
			color: black; 
		    font-size: 1.2em;
		    box-sizing: border-box;
		    min-width: 0;           /* sehr wichtig, verhindert Overflow */
		    overflow-wrap: break-word; /* verhindert, dass Text die Box sprengt */
		}
		
		#current-values strong {
		    display: block;
		    font-size: 1em;
		    margin-bottom: 6px;
			color: gray; 
		}
		
		#current-values span {
		    font-size: 1.6em;
		    font-weight: bold;
		    color: #333;
		}


  
      /* --- Untere Steuerzeile ausblenden --- */
      #below\ chart {
        display: none !important;
      }
      
    </style>
</html>
