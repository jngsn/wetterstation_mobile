<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style>
		  html {
		    font-size: 16px; /* 1rem = 16px */
		  }
		  body {
		    -webkit-text-size-adjust: 100%; /* verhindert iOS-Autozoom */
		    font-family: Arial, sans-serif; /* oder dein gewünschter Font */
		  }
		</style>

	  
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://code.highcharts.com/stock/highstock.js"></script>
    <script src="https://code.highcharts.com/stock/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script type="text/javascript">
    
	var dynamicChart;
	var channelsLoaded = 0;
	var channelKeys =[];
	channelKeys.push({
            channelNumber: 1304805,
            name: 'Wetterstation',
            key: '1H5R2K6OL295TNP8',
            fieldList: [
                {field:1, axis:'T', unit:'°C'},
                {field:2, axis:'H', unit:'%'},
                {field:3, axis:'T', unit:'g/m³'},
                {field:4, axis:'T', unit:'°C'},
                {field:5, axis:'T', unit:'°C'},
                {field:6, axis:'T', unit:'°C'},
                {field:7, axis:'T', unit:'mm'},   // spezielle Einheit für Feld 7
                {field:8, axis:'P', unit:''}      // keine Einheit für Feld 8
            ]
        });

	                
	// user's timezone offset
	var myOffset = new Date().getTimezoneOffset();
	
	// converts date format from JSON
	function getChartDate(d) {
	    return Date.UTC(d.substring(0,4), d.substring(5,7)-1, d.substring(8,10), d.substring(11,13), d.substring(14,16), d.substring(17,19)) - (myOffset * 60000);
	}
	
	      // Hide all series, via 'Hide All' button.  Then user can click on serries name in legent to show series of interest.      
	function HideAll(){
	  for (var index=0; index<dynamicChart.series.length; index++)  // iterate through each series
	  { 
	    if (dynamicChart.series[index].name == 'Navigator')
	      continue;
	    dynamicChart.series[index].hide();
	    //window.console && console.log('Series Number:',index,' Name:',dynamicChart.series[index].name);
	  }
	  //});
	            
	}
	      
	      //  This is where the chart is generated.
	$(document).ready(function() 
	{
	 //Add Channel Load Menu
	 var menu=document.getElementById("Channel Select");
	 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
	 {
	   window.console && console.log('Name',channelKeys[channelIndex].name);
	   var menuOption =new Option(channelKeys[channelIndex].name,channelIndex);
	   menu.options.add(menuOption,channelIndex);
	 }
	 var last_date; // variable for the last date added to the chart
	 window.console && console.log('Testing console');
	 //make series numbers for each field
	 var seriesCounter=0
	 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
	  {
	    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // iterate through each channel
	      {
	        channelKeys[channelIndex].fieldList[fieldIndex].series = seriesCounter; 
	        seriesCounter++;
	      }
	  }
 //make calls to load data from each channel into channelKeys array now
 // draw the chart when all the data arrives, later asyncronously add history
 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    channelKeys[channelIndex].loaded = false;  
    loadThingSpeakChannel(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList);
    
  }
 //window.console && console.log('Channel Keys',channelKeys);
 
 // load the most recent 2500 points (fast initial load) from a ThingSpeak channel into a data[] array and return the data[] array
 function loadThingSpeakChannel(sentChannelIndex,channelNumber,key,sentFieldList) {
   var fieldList= sentFieldList;
   var channelIndex = sentChannelIndex;
   // get the Channel data with a webservice call
   $.getJSON('https://api.thingspeak.com/channels/'+channelNumber+'/feed.json?&amp;offset=0&amp;results=2500;api_key='+key, function(data)
   //$.getJSON('https://www.thingspeak.com/channels/'+channelNumber+'/feed.json?callback=?&amp;offset=0&amp;results=2500;key='+key, function(data)
   {
	   // if no access
	   if (data == '-1') {
       $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
       window.console && console.log('Thingspeak Data Loading Error');
     }
     for (var fieldIndex=0; fieldIndex<fieldList.length; fieldIndex++)  // iterate through each field
     {
       fieldList[fieldIndex].data =[];
       for (var h=0; h<data.feeds.length; h++)  // iterate through each feed (data point)
       {
         var p = []//new Highcharts.Point();
         var fieldStr = "data.feeds["+h+"].field"+fieldList[fieldIndex].field;
		  	 var v = eval(fieldStr);
 		  	p[0] = getChartDate(data.feeds[h].created_at);
	 	  	p[1] = parseFloat(v);
	 	  	// if a numerical value exists add it
	   		if (!isNaN(parseInt(v))) { fieldList[fieldIndex].data.push(p); }
       }
       fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
	   }
     window.console && console.log('getJSON field name:',fieldList[0].name);
     channelKeys[channelIndex].fieldList=fieldList;
     channelKeys[channelIndex].loaded=true;
     channelsLoaded++;
     window.console && console.log('channels Loaded:',channelsLoaded);
     window.console && console.log('channel index:',channelIndex);
     if (channelsLoaded==channelKeys.length){createChart();}
	 })
   .fail(function() { alert('getJSON request failed! '); });
 }
 
 function startWeatherEmojiUpdater() {
    updateWeatherEmoji();               // Sofort das aktuelle Emoji setzen
    setInterval(updateWeatherEmoji, 60000); // Dann jede Minute aktualisieren
  }

 // create the chart when all data is loaded
 function createChart() {
	// specify the chart options
	var chartOptions = {
	  chart: 
    {
		  renderTo: 'chart-container',
      zoomType:'y',
			events: 
      {
        load: function() 
        {
				  if ('true' === 'true' && (''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1)) 
          {
            // If the update checkbox is checked, get latest data every 15 seconds and add it to the chart
						setInterval(function() 
            {
             if (document.getElementById("Update").checked)
             {
              for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
              {  
               (function(channelIndex)
               {
                // get the data with a webservice call
				$.getJSON('https://api.thingspeak.com/channels/'+channelKeys[channelIndex].channelNumber+'/feed/last.json?&amp;offset=0&amp;location=false;api_key='+channelKeys[channelIndex].key, function(data)
				//$.getJSON('https://www.thingspeak.com/channels/'+channelKeys[channelIndex].channelNumber+'/feed/last.json?callback=?&amp;offset=0&amp;location=false;key='+channelKeys[channelIndex].key, function(data)   
                { 
                  for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)
                  {
                    // if data exists
                    var fieldStr = "data.field"+channelKeys[channelIndex].fieldList[fieldIndex].field;
                    var chartSeriesIndex=channelKeys[channelIndex].fieldList[fieldIndex].series;
                    if (data && eval(fieldStr)) 
                    {
                      var p = []//new Highcharts.Point();
                      var v = eval(fieldStr);
                      p[0] = getChartDate(data.created_at);
                      p[1] = parseFloat(v);
                      // get the last date if possible
                      if (dynamicChart.series[chartSeriesIndex].data.length > 0) 
                      { 
                        last_date = dynamicChart.series[chartSeriesIndex].data[dynamicChart.series[chartSeriesIndex].data.length-1].x; 
                      }
                      var shift = false ; //default for shift
                      // if a numerical value exists and it is a new date, add it
                      if (!isNaN(parseInt(v)) && (p[0] != last_date)) 
                      {
                        dynamicChart.series[chartSeriesIndex].addPoint(p, true, shift);
                      }   
                    }
                    //window.console && console.log('channelKeys:',channelKeys);
                    //window.console && console.log('chartSeriesIndex:',chartSeriesIndex);
                    //window.console && console.log('channel index:',channelIndex);
                    //window.console && console.log('field index:',fieldIndex);
                    //window.console && console.log('update series name:',dynamicChart.series[chartSeriesName].name);
                    //window.console && console.log('channel keys name:',channelKeys[channelIndex].fieldList[fieldIndex].name);
                  }
                  
                  
                });
               })(channelIndex);
              }
              // Nach dem Update der Series auch die Anzeige aktualisieren:
              updateCurrentValues();
             }
						}, 10000);
					}
				}
			}
		},
		rangeSelector: {
			buttons: [{
				count: 30,
				type: 'minute',
				text: '30M'
			},{
				count: 1,
				type: 'hour',
				text: '1H'
      },{
				count: 2,
				type: 'hour',
				text: '2H'
      },{
				count: 4,
				type: 'hour',
				text: '4H'
      }, {
				count: 12,
				type: 'hour',
				text: '12H'
      }, {
				count: 1,
				type: 'day',
				text: 'D'
      }, {
				count: 1,
				type: 'week',
				text: 'W'
      }, {
				count: 1,
				type: 'month',
				text: 'M'
      }, {
				count: 1,
				type: 'year',
				text: 'Y'
			}, {
				type: 'all',
				text: 'All'
			}],
			inputEnabled: true,
			selected: 3,
			buttonTheme: {
                              width: 25,       // Breite der Buttons
                              height: 25,      // Höhe der Buttons
                              style: {
                                        fontSize: '14px'
                                    }
                              }
		},
    title: {
			text: ''
		},
		plotOptions: {
		  line: {
        gapSize:5
				//color: '#d62020'
				//  },
				//  bar: {
				//color: '#d52020'
				//  },
				//  column: {
			},
			series: {
			  marker: {
				  radius: 2
				},
				animation: true,
				step: false,
        turboThrehold:1000,
				borderWidth: 0
			}
		},
    tooltip: {
      valueDecimals: 2,
      //valueSuffix: '°F',
      xDateFormat:'%Y-%m-%d<br/>%H:%M:%S'
			// reformat the tooltips so that local times are displayed
			//formatter: function() {
      //var d = new Date(this.x + (myOffset*60000));
      //var n = (this.point.name === undefined) ? '' : '<br/>' + this.point.name;
      //return this.series.name + ':<b>' + this.y + '</b>' + n + '<br/>' + d.toDateString() + '<br/>' + d.toTimeString().replace(/\(.*\)/, "");
			//}
    },
		xAxis: {
		  type: 'datetime',
      ordinal:false,
      min: Date.UTC(2013,02,28),
			dateTimeLabelFormats : {
        hour: '%k %p',
        minute: '%k:%M'
        //hour: '%l %p',
        //minute: '%l:%M %p'
      },
      title: {
        text: 'test'
			}
		},
		yAxis: [{
            title: {
                //text: 'Temperatur (°C)'
            },
            id: 'T'
    }, {
            title: {
                //text: 'Luftfeuchtigkeit (g/m²)'
            },
            opposite: false,
            id: 'H',
            labels: {
                  align: 'left', // linksbündig innerhalb des Achsenbereichs
                  x: 0, // verschiebt die Achsenwerte nach links
                  y: -2,
                  style: {
                      fontSize: '12px' // optional Schriftgröße anpassen
                  }
            }
    }, {
            title: {
                //text: 'Luftdruck'
            },
            opposite: false,
            id: 'P',
            labels: {
                  align: 'left', // linksbündig innerhalb des Achsenbereichs
                  x: 0, // verschiebt die Achsenwerte nach links
                  y: 11,
                  style: {
                      fontSize: '12px' // optional Schriftgröße anpassen
                  }
            }
    }],
		exporting: {
		enabled: true,
		sourceWidth: 1500, 
                sourceHeight: 1000,
                scale: 1 ,
      csv: {
        dateFormat: '%d/%m/%Y %H:%M:%S'
        }
		},
		legend: {
                    enabled: false,
                    itemStyle: {
                        fontSize: '30px',
                        fontWeight: 'bold',
                        cursor: 'pointer'
                    },
                    itemHoverStyle: {
                        color: '#000000'
                    },
                    symbolHeight: 20, // Höhe des Legenden-Kästchens
                    symbolWidth: 20   // Breite des Legenden-Kästchens
                },
    navigator: {
            //baseSeries: 0,  //select which series to show in history navigator, First series is 0
            //series: {
            //      includeInCSVExport: false
            enabled: false // Navigator ausblenden
		},    
    series: []
    //series: [{data:[[getChartDate("2013-06-16T00:32:40Z"),75]]}]      
	};

	// add all Channel data to the chart
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // add each field
    {
      window.console && console.log('Channel '+channelIndex+' field '+fieldIndex);
      chartOptions.series.push({data:channelKeys[channelIndex].fieldList[fieldIndex].data,
                                index:channelKeys[channelIndex].fieldList[fieldIndex].series,
                                yAxis:channelKeys[channelIndex].fieldList[fieldIndex].axis,
                                //visible:false,
                              name: channelKeys[channelIndex].fieldList[fieldIndex].name});
    }
    updateCurrentValues();
  }
	// set chart labels here so that decoding occurs properly
	//chartOptions.title.text = data.channel.name;
	chartOptions.xAxis.title.text = 'Uhrzeit';

	// draw the chart
  dynamicChart = new Highcharts.StockChart(chartOptions);
  
  // Felder bei Start ausbleden
  dynamicChart.series[4].hide();  
  dynamicChart.series[5].hide();  

  // Buttons erstellen
  createSeriesButtons();
  
  // update series number to account for the navigator series (The historical series at the bottom) which is the first series.
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // and each field
    {
      for (var seriesIndex=0; seriesIndex<dynamicChart.series.length; seriesIndex++)  // compare each series name
      {
        if (dynamicChart.series[seriesIndex].name == channelKeys[channelIndex].fieldList[fieldIndex].name)
        {
          channelKeys[channelIndex].fieldList[fieldIndex].series = seriesIndex;
        }
      }
    }
  }          
  // add all history
  //dynamicChart.showLoading("Loading History..." );
  window.console && console.log('Channels: ',channelKeys.length);
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    window.console && console.log('channelIndex: ',channelIndex);
    (function(channelIndex)
      {
        //load only 1 set of 8000 points
        loadChannelHistory(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList,0,1); 
      }
    )(channelIndex);
  }
  // Emoji-Updater starten
    startWeatherEmojiUpdater();
 }
 
});

// === Aktuelle Uhrzeit und Datum rechts oben anzeigen ===
function updateClock() {
  const now = new Date();

  // Deutsche Wochentage & Monate
  const days = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
  const months = ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"];

  const dayName = days[now.getDay()];
  const day = now.getDate();
  const month = months[now.getMonth()];

  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  
  const formatted = `${dayName}, ${day}. ${month} - ${hours}:${minutes}`;

  document.getElementById("clock").textContent = formatted;
}

// Uhr jede Sekunde aktualisieren
setInterval(updateClock, 1000);
updateClock(); // sofort starten

		
function updateCurrentValues() {
  let container = document.getElementById("current-values");
  container.innerHTML = ''; // Leeren vor Neubefüllung

  for (let channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) {
    const channel = channelKeys[channelIndex];

    for (let i = 0; i < channel.fieldList.length; i++) {
      const field = channel.fieldList[i];
      let latestValue = 'n/a';

      if (field.data && field.data.length > 0) {
        latestValue = field.data[field.data.length - 1][1];
      }

	  //buttonscurrentvalue
      let box = document.createElement('div');
      box.style.border = "1px solid #ccc";
      box.style.padding = "2px";
      box.style.borderRadius = "5px";
      box.style.minWidth = "auto";
      box.style.textAlign = "center";
      box.style.backgroundColor = "#f9f9f9";

      // Einheit anhängen, falls definiert
      const unit = field.unit ? ` ${field.unit}` : '';
      const roundedValue = Number(latestValue).toFixed(1);
      const unitHTML = field.unit ? `<span style="font-size: 0.6em;">${field.unit}</span>` : '';
      box.innerHTML = `<span style="font-size: 1.5rem; font-weight: bold;">${roundedValue}${unitHTML}</span><br>
                      <strong style="font-size: 0.6rem;">${field.name}</strong>`;

      container.appendChild(box);
    }
  }
}



function updateWeatherEmoji() {
    const channel = channelKeys[0]; // erster Kanal

    // Feste Felder abrufen
    const tempField = channel.fieldList.find(f => f.field === 1);
    const humField = channel.fieldList.find(f => f.field === 2);
    const pressureField = channel.fieldList.find(f => f.field === 8);

    // Prüfen, ob die Felder existieren und Daten enthalten
    if (!tempField || !humField || !pressureField) return;
    if (!tempField.data || !tempField.data.length) return;
    if (!humField.data || !humField.data.length) return;
    if (!pressureField.data || !pressureField.data.length) return;

    const latestTemp = tempField.data[tempField.data.length - 1][1];
    const latestHum = humField.data[humField.data.length - 1][1];
    const latestPressure = pressureField.data[pressureField.data.length - 1][1];

    let emoji = "🌡️"; // Standard

    // Logik für Emoji basierend auf mehreren Parametern
    if (latestTemp <= 0) {
        emoji = "❄️"; // Kalt/Schnee
    } else if (latestHum > 80 && latestTemp < 20) {
        emoji = "🌧️"; // Regen
    } else if (latestHum < 50 && latestTemp > 25) {
        emoji = "☀️"; // Sonnig/Heiß
    } else if (latestHum > 60 && latestPressure < 1000) {
        emoji = "⛈️"; // Gewitterwahrscheinlichkeit
    } else if (latestHum >= 50 && latestTemp <= 15) {
        emoji = "🌥️"; // Wolkig/Kühl
    } else {
        emoji = "🌤️"; // Mild/Sonnig
    }

    document.getElementById("header-title").innerHTML = `Wetterstation ${emoji}`;
}

// === Wichtiger Schritt: erst nach dem Laden der Daten aufrufen ===
function startWeatherEmojiUpdater() {
    // Sofort aufrufen, wenn Daten da sind
    updateWeatherEmoji();
    // Dann jede Minute aktualisieren
    setInterval(updateWeatherEmoji, 60000);
}

// Hier aufrufen, **erst nachdem die ThingSpeak-Daten geladen sind**
// Beispiel: direkt am Ende von createChart()
createChart = function() {
    // ... dein bestehender createChart Code ...

    dynamicChart = new Highcharts.StockChart(chartOptions);

    // Nach dem Zeichnen des Charts die Emoji-Funktion starten
    startWeatherEmojiUpdater();

    // ... restlicher Code ...
};

function createSeriesButtons() {
    const container = document.getElementById("buttons-container");

    // Container als flexbox für gleichmäßige Anordnung
    container.innerHTML = ''; // vorherige Buttons löschen
    container.style.display = 'flex';
    container.style.flexWrap = 'wrap';
    container.style.alignItems = 'center'; // vertikal zentrieren
    container.style.gap = '2px';           // Abstand zwischen Buttons

    for (let channelIndex = 0; channelIndex < channelKeys.length; channelIndex++) {
        const channel = channelKeys[channelIndex];

        for (let i = 0; i < channel.fieldList.length; i++) {
            const field = channel.fieldList[i];

            // Nur bestimmte Buttons erstellen
            if (field.name.includes("Tages min. Temperatur") || field.name.includes("Tages max. Temperatur")) {
                continue; // Button nicht erzeugen
            }
			// Chartbuttons
            const button = document.createElement('button');
            button.style.width = '58px';
            button.style.minHeight = '40px';      // garantiert Mindesthöhe
            button.style.fontSize = '8px';
            button.style.fontWeight = 'bold';
            button.style.margin = '5px';
            button.style.whiteSpace = 'normal';   // Text darf umbrechen
            button.style.textAlign = 'center';
            button.style.padding = '0';         // innenabstand
            button.style.boxSizing = 'border-box';
            button.style.display = 'flex';
            button.style.alignItems = 'center';      // Text vertikal zentrieren
            button.style.justifyContent = 'center';  // Text horizontal zentrieren
            button.textContent = field.name;
            button.style.border = 'none';          // kein Rand
            button.style.outline = 'none';         // kein Fokus-Rahmen

            // Statusfarbe initial setzen
            const series = dynamicChart.series[field.series];
            button.style.backgroundColor = series.visible ? '#e6eaff' : '#f7f7f7'; // blau = sichtbar, grau = ausgeblendet
            button.style.color = series.visible ? 'black' : 'gray';

            // Klick-Handler
            button.onclick = function() {
                series.visible ? series.hide() : series.show();
                // Buttonfarbe aktualisieren
                button.style.backgroundColor = series.visible ? '#e6eaff' : '#f7f7f7'; // blau = sichtbar, grau = ausgeblendet
                button.style.color = series.visible ? 'black' : 'gray';
            };

            container.appendChild(button);
        }
    }
}


      
function loadOneChannel(){ 
  // load a channel selected in the popUp menu.
  var selectedChannel=document.getElementById("Channel Select");
  var maxLoads=document.getElementById("Loads").value ;
  var channelIndex = selectedChannel.selectedIndex;
  loadChannelHistory(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList,0,maxLoads); 
} 

// load next 8000 points from a ThingSpeak channel and addPoints to a series
function loadChannelHistory(sentChannelIndex,channelNumber,key,sentFieldList,sentNumLoads,maxLoads) {
   var numLoads=sentNumLoads
   var fieldList= sentFieldList;
   var channelIndex = sentChannelIndex;
   var first_Date = new Date();
   if (typeof fieldList[0].data[0] != "undefined") first_Date.setTime(fieldList[0].data[0][0]+7*60*60*1000);//adjust for 7 hour difference from GMT (Zulu time)
   else if (typeof fieldList[1].data[0] != "undefined") first_Date.setTime(fieldList[1].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[2].data[0] != "undefined") first_Date.setTime(fieldList[2].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[3].data[0] != "undefined") first_Date.setTime(fieldList[3].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[4].data[0] != "undefined") first_Date.setTime(fieldList[4].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[5].data[0] != "undefined") first_Date.setTime(fieldList[5].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[6].data[0] != "undefined") first_Date.setTime(fieldList[6].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[7].data[0] != "undefined") first_Date.setTime(fieldList[7].data[0][0]+7*60*60*1000);
   var end = first_Date.toJSON();
   window.console && console.log('earliest date:',end);
   window.console && console.log('sentChannelIndex:',sentChannelIndex);
   window.console && console.log('numLoads:',numLoads);
   // get the Channel data with a webservice call
   $.getJSON('https://api.thingspeak.com/channels/'+channelNumber+'/feed.json?&amp;offset=0&amp;start=2020-01-01T00:00:00;end='+end+';api_key='+key, function(data) 
   //$.getJSON('https://www.thingspeak.com/channels/'+channelNumber+'/feed.json?callback=?&amp;offset=0&amp;start=2013-01-20T00:00:00;end='+end+';key='+key, function(data) 
   {
	   // if no access
	   if (data == '-1') {
       $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
       window.console && console.log('Thingspeak Data Loading Error');
     }
     for (var fieldIndex=0; fieldIndex<fieldList.length; fieldIndex++)  // iterate through each field
     {
       //fieldList[fieldIndex].data =[];
       for (var h=0; h<data.feeds.length; h++)  // iterate through each feed (data point)
       {
         var p = []//new Highcharts.Point();
         var fieldStr = "data.feeds["+h+"].field"+fieldList[fieldIndex].field;
		  	 var v = eval(fieldStr);
 		  	p[0] = getChartDate(data.feeds[h].created_at);
	 	  	p[1] = parseFloat(v);
	 	  	// if a numerical value exists add it
	   		if (!isNaN(parseInt(v))) { fieldList[fieldIndex].data.push(p); }
       }
       fieldList[fieldIndex].data.sort(function(a,b){return a[0]-b[0]});
       dynamicChart.series[fieldList[fieldIndex].series].setData(fieldList[fieldIndex].data,false);
       //dynamicChart.series[fieldList[fieldIndex].series].addPoint(fieldList[fieldIndex].data,false);
       //fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
       //window.console && console.log('data added to series:',fieldList[fieldIndex].series,fieldList[fieldIndex].data);
	   }
     channelKeys[channelIndex].fieldList=fieldList;
     dynamicChart.redraw()
     window.console && console.log('channel index:',channelIndex);
     numLoads++;
     if (numLoads<maxLoads) {loadChannelHistory(channelIndex,channelNumber,key,fieldList,numLoads,maxLoads);}
	 });
}

</script>
	  
<title>Wetterstation</title>
</head>
<body style="background-color: white;">

<!-- Überschrift -->
<h1 style="display: flex; justify-content: space-between; align-items: center; font-family: Arial; font-size: 1.8rem;">
  <span id="header-title">Wetterstation</span>
  <span id="clock" style="font-size: 1.0rem; font-weight: bold; color: #777777;"></span>
</h1>

<!-- Zusatzinfos -->
<p style="
  font-size: 0.5rem; 
  font-family: Arial;
  color: #666; 
  margin-top: 0px; 
  display: flex; 
  justify-content: space-between;
">
  <span>📍 Hochspeyer, Rheinland-Pfalz - 280 m ü. NN</span>
  <span>ESP8266 D1 mini pro, BME280 & MISOL Regenmesser </span>
</p>

<!-- Felder aktuelle Werte -->
<div id="current-values" style="font-family: Arial; margin: 10px; gap: 5px;">
  <!-- Hier werden die aktuellen Werte dynamisch eingefügt -->
</div>

<!-- Chart / Diagramm -->
<div id="chart-container" style="height: 700px;"><br>
  Diagramm wird geladen...<br>
</div>

<!-- Buttons zum ein/ausschalten der Linien -->
<div id="buttons-container" style="margin-top:10px;"></div>
<div style="height:20px;"></div>

<!-- Steuerelemente des Charts - Ausgeblendet -->
<div id="below chart"> <button style="width: 110px; margin-top: -18px;" value="Hide All"
	name="Hide All Button"
	onclick="HideAll();">Alle ausbleden</button><button style="width: 200px; margin-top: -18px;" value="Load More Data"
	name="Load More Data"
	onclick="loadOneChannel();">Mehr historische Daten laden</button>
  <select id="Channel Select">
  </select>
  <select id="Loads">
	<option value="1">1 Datensätze</option>
	<option value="2">2 Datensätze</option>
	<option value="3">3 Datensätze</option>
	<option value="4">4 Datensätze</option>
	<option value="5">5 Datensätze</option>
	<option value="6">6 Datensätze</option>
	<option value="7">7 Datensätze</option>
	<option value="8">8 Datensätze</option>
	<option value="9">9 Datensätze</option>
	<option value="10">10 Datensätze</option>
	<option value="15">15 Datensätze</option>
	<option value="20"selected="selected">20 Datensätze</option>
	<option value="25">25 Datensätze</option>
	<option value="30">30 Datensätze</option>
	<option value="40">40 Datensätze</option>
	<option value="50">50 Datensätze</option>
  </select>
  <input id="Update" name="Update" type="checkbox" checked><span style="font-family: Arial;">Daten automatisch nachladen</span> 
  <span id="Latency" style="font-family: Arial;">(Latency)</span>
</div>
    
<!-- Button für mehr historische Daten -->
<div style="text-align:center; margin-top: 10px;">
  <button 
	onclick="loadOneChannel();" 
	style="padding: 10px 20px; font-size: 1rem; border:none; outline:none; border-radius:0px; background-color:#e6eaff; color:#333; cursor:pointer;">
	Mehr historische Daten laden
  </button>
</div>

	  <!-- Trennlinie -->
<div style="height:20px;"></div>
<hr style="border: none; border-top: 1px solid #ccc; margin: 5px 0 10px 0;">
    
<!-- Wettervorhersage Widget -->    
<a class="weatherwidget-io" href="https://forecast7.com/de/49d447d90/hochspeyer/" data-label_1="HOCHSPEYER" data-label_2="WEATHER" data-icons="Climacons Animated" data-mode="Forecast" data-theme="original" data-basecolor="#e6eaff" data-textcolor="#535353" data-highcolor="#a15757" data-lowcolor="#5296f8" >HOCHSPEYER WEATHER</a>
<script>
!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src='https://weatherwidget.io/js/widget.min.js';fjs.parentNode.insertBefore(js,fjs);}}(document,'script','weatherwidget-io-js');
</script>



<!-- Impressum Button -->
<button onclick="document.getElementById('impressum').style.display='block'" 
        style="position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
               border:none; outline:none;
               font-size:0.9em; color:#666; cursor:pointer;">
  Impressum
</button>

<!-- Overlay -->
<div id="impressum" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
     background-color:rgba(0,0,0,0.7); color:white; padding:50px; box-sizing:border-box; overflow:auto;">
  <div style="background-color:#fff; color:#000; padding:20px; border-radius:8px; max-width:600px; margin:auto; font-family: Arial, sans-serif;">
    <h2>Impressum</h2>

    <p><strong>Angaben gemäß § 5 TMG:</strong><br>
    Jan Gassen<br>
    Über den Bächelwiesen 1<br>
    67691 Hochspeyer<br>
    Deutschland</p>

    <p><strong>Kontakt:</strong><br>
    E-Mail: jg-pp [at] mail [dot] de<br></p>

    <p><strong>Haftungsausschluss:</strong><br>
    Trotz sorgfältiger inhaltlicher Kontrolle übernehmen wir keine Haftung für die Inhalte externer Links.<br>Für den Inhalt der verlinkten Seiten sind ausschließlich deren Betreiber verantwortlich.</p>
    
    <p><strong>Hinweis:</strong> Diese Website ist ein privates / nicht kommerzielles Projekt.</p>
    <button onclick="document.getElementById('impressum').style.display='none'">Schließen</button>
  </div>
</div>


	<!-- Felder aktuelle Werte oben -->
  </body>
      <style>
		body {
		    margin: 0;
		    padding: 0;
		    box-sizing: border-box;
			overflow-x: hidden; /* horizontalen Scroll komplett verhindern */
		}
		
		#current-values {
		  	display: grid;
		    grid-template-columns: repeat(4, 1fr); /* genau 4 Spalten */
		    gap: 8px;
		    width: 100%;           /* volle Breite des Viewports */
		    max-width: 100%;       /* auf Viewport begrenzen */
		    margin: 0 auto;        /* zentriert */
		    padding: 0;            /* kein zusätzlicher Innenabstand */
		    box-sizing: border-box;
		}

		
		#current-values div {
		    border: 1px solid #ccc;
		    padding: 10px;
		    border-radius: 8px;
		    text-align: center;
		    background-color: #f0f0f0;
		    font-family: Arial, sans-serif;
		    font-size: 1.2em;
		    box-sizing: border-box;
		    min-width: 0;          /* verhindert, dass Boxen überlaufen */
		    overflow-wrap: break-word; /* Text umbrechen, falls nötig */
		}

		
		#current-values strong {
		    display: block;
		    font-size: 1em;
		    margin-bottom: 6px;
		}
		
		#current-values span {
		    font-size: 1.6em;
		    font-weight: bold;
		    color: #333;
		}


  
      /* --- Untere Steuerzeile ausblenden --- */
      #buttons-container, #below\ chart {
		    max-width: 100%;
		    overflow-x: auto; /* falls doch zu viel Inhalt, Scroll nur hier */
		  	display: none !important;
		}

      
    </style>
</html>
